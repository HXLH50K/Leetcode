from typing import List


class Solution:
    def minOperations(self, nums: List[int]) -> int:
        """
        单调栈优化（O(n) 时间，O(1) 额外空间；栈高度为当前无 0 分隔段内严格递增层数）。

        操作规则：一次操作选取子数组 [i,j]，把其中“最小值”的所有出现位置置 0。被置 0 的位置
        将成为未来的“分隔符”，后续任何包含这些 0 的子数组的最小值都是 0，无法再同时清除更大的数，
        等价于：较小数先被移除后会把数组切碎，导致更大的数可能需要分多次清除。

        关键结论：
        对于一个被 0 分隔开的连续段，我们自左向右：
        - 维护一条“当前有效的严格递增链”（单调递增栈）。栈中的元素代表尚未被更小值分割的高度层。
        - 当遇到一个更小的正数时，所有比它大的栈元素未来一定无法在同一次操作中跨过它一起被清除，
          因此弹出（这些层在之后不会再贡献额外操作）。
        - 当当前数比栈顶大（形成新的更高一层）时，必然需要新增一次操作来在未来某个时刻清除此层，
          计数加 1，并入栈。
        - 当当前数等于栈顶时，不增加操作（它与之前同层，可在同一次操作被一起清除）。
        - 遇到 0 时整段结束，栈清空（因为 0 已经把之前的层全部截断，后面重新开始）。

        这样，答案就是所有段内“形成新的高度层”的次数之和。
        例：
        [3,1,2,1] 过程：
          num=3 => 新层 ans=1, stack=[3]
          num=1 => 弹出 3, 新层 ans=2, stack=[1]
          num=2 => 新层 ans=3, stack=[1,2]
          num=1 => 弹出 2 后与栈顶 1 相等，不加
        输出 3（与题意示例一致）

        [1,2,1,2,1,2]:
          1(+1),2(+1),1(pop2 eq1),2(+1),1(pop2 eq1),2(+1) => 4

        正确性基于：每个被记录的“新层”最终必须至少用一次操作选择一个包含其最小值的子数组并把该层对应值置 0；
        不会重复计数同层；弹出操作保证不会对后续造成过度统计。

        """
        ans = 0
        stack = []
        for num in nums:
            if num == 0:
                stack.clear()
                continue
            # 仅处理正数
            while stack and stack[-1] > num:
                stack.pop()
            if num > 0 and (not stack or stack[-1] < num):
                ans += 1
                stack.append(num)
            # equal 情况不增加操作
        return ans
